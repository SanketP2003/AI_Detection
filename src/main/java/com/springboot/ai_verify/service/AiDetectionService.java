package com.springboot.ai_verify.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import java.time.Duration;
import java.util.List;
import java.util.concurrent.TimeoutException;

@Service
public class AiDetectionService {

    private final WebClient webClient;

    @Value("${gemini.api.url}")
    private String geminiApiUrl;

    @Value("${gemini.api.key}")
    private String geminiApiKey;

    private static final String SYSTEM_PROMPT = """
        Analyze the given text and assess the likelihood that it was generated by an AI versus a human. 
        Use a multifaceted evaluation strategy based on natural language features, writing dynamics, and 
        thematic coherence. The assessment must be grounded in the following metrics and considerations:
        Evaluation Metrics:
        - Perplexity (0–100): Measures how predictable the text is. AI-generated content typically uses highly probable next-word predictions, leading to lower perplexity scores (e.g., 0–40). Human writing often introduces less predictable language, creative phrasings, idioms, and interruptions that result in higher perplexity (e.g., 40–70). Very high perplexity (>70) may indicate incoherence or randomness, suggesting either low-quality AI output or disorganized human writing.
        - Burstiness (0–100): Evaluates variance in sentence structure, length, punctuation, and rhythm. Human writers tend to have irregular patterns, mixing short and long sentences and switching between formal and informal tones. This results in high burstiness (60–100). AI-generated content often exhibits low burstiness (20–50), maintaining consistent sentence length and syntactic simplicity.
        - Consistency (0–100): Reflects the thematic and stylistic steadiness of the text. AI text is often overly consistent, staying narrowly on topic, rarely diverging in tone or context (scoring 70–100). Human writing often shifts tone, introduces side thoughts, and shows personal bias or emotion, which lowers consistency (30–60). Extremely low consistency (<30) may indicate lack of focus or clarity.
        
        Provide ONLY a JSON response in this exact format, with no other text or explanations before or after the JSON block:
        {
          "probability": 0-100,
          "metrics": {
            "perplexity": 0-100,
            "burstiness": 0-100,
            "consistency": 0-100
          },
          "patterns": ["pattern1", "pattern2", ...],
          "analysis": "Detailed explanation of the findings, summarizing why the text is likely AI or human-written based on the metrics."
        }
        """;

    public AiDetectionService(WebClient.Builder webClientBuilder, ObjectMapper objectMapper) {
        this.webClient = webClientBuilder.build();
    }

    // Define records for Gemini API request and response structures
    public record GeminiRequest(List<Content> contents) {}
    public record Content(List<Part> parts) {}
    public record Part(String text) {}

    public record GeminiResponse(List<Candidate> candidates) {}
    public record Candidate(Content content) {}


    public Mono<String> detectAiContent(String textToAnalyze) {
        // Construct the full prompt
        String fullPrompt = SYSTEM_PROMPT + "\n\nHere is the text to analyze:\n" + textToAnalyze;

        // Construct the Gemini payload
        Part part = new Part(fullPrompt);
        Content content = new Content(List.of(part));
        GeminiRequest payload = new GeminiRequest(List.of(content));

        return webClient.post()
                .uri(geminiApiUrl)
                .header("x-goog-api-key", geminiApiKey)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(payload)
                .retrieve()
                .bodyToMono(GeminiResponse.class)
                .retryWhen(Retry.backoff(3, Duration.ofSeconds(5))
                        .jitter(0.5)
                        .filter(throwable -> {
                            if (throwable instanceof WebClientResponseException) {
                                int statusCode = ((WebClientResponseException) throwable).getStatusCode().value();
                                // Retry on 429 Too Many Requests and 5xx server errors
                                return statusCode == 429 || (statusCode >= 500 && statusCode < 600);
                            }
                            // Also retry on timeout
                            return throwable instanceof TimeoutException;
                        })
                        .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -> retrySignal.failure()))
                .map(this::processGeminiResponse)
                .onErrorResume(e -> {
                    System.err.println("Error calling Gemini API: " + e.getMessage());
                    return Mono.just("{\"error\": \"Failed to get analysis from the AI model. Please try again later.\"}");
                });
    }

    private String processGeminiResponse(GeminiResponse apiResponse) {
        if (apiResponse != null && apiResponse.candidates() != null && !apiResponse.candidates().isEmpty()) {
            Candidate firstCandidate = apiResponse.candidates().get(0);
            if (firstCandidate.content() != null && firstCandidate.content().parts() != null && !firstCandidate.content().parts().isEmpty()) {
                String jsonResponse = firstCandidate.content().parts().get(0).text();
                // The model should return a JSON string, so we just return it.
                return jsonResponse.trim();
            }
        }
        return "{\"error\": \"No content found in AI model response.\"}";
    }
}