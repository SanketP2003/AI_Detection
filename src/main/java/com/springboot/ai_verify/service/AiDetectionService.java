package com.springboot.ai_verify.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import java.time.Duration;
import java.util.List;
import java.util.concurrent.TimeoutException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
public class AiDetectionService {

    private final WebClient webClient;
    private final ObjectMapper objectMapper;

    @Value("${mistralmodel.api.url}")
    private String mistralApiUrl;

    @Value("${mistralmodel.api.key}")
    private String mistralApiKey;

    @Value("${mistralmodel.model}")
    private String mistralModel;

    private static final String SYSTEM_PROMPT = """
        Analyze the given text and assess the likelihood that it was generated by an AI versus a human. 
        Provide ONLY a JSON response in this exact format. All newlines inside JSON string values (e.g., in the 'analysis' field) MUST be escaped as \\n.
        {
          "probability": 0-100,
          "metrics": {
            "perplexity": 0-100,
            "burstiness": 0-100,
            "consistency": 0-100
          },
          "patterns": ["pattern1", "pattern2", ...],
          "analysis": "Detailed explanation of the findings, summarizing why the text is likely AI or human-written based on the metrics."
        }
        """;

    public AiDetectionService(WebClient.Builder webClientBuilder, ObjectMapper objectMapper) {
        this.webClient = webClientBuilder.build();
        this.objectMapper = objectMapper;
    }

    public record MistralMessage(String role, String content) {}
    public record MistralRequest(String model, List<MistralMessage> messages, boolean stream) {}
    public record MistralResponse(List<Choice> choices) {}
    public record Choice(MistralMessage message) {}

    public Mono<String> detectAiContent(String textToAnalyze) {
        if (mistralApiKey == null || mistralApiKey.isBlank()) {
            return Mono.just("{\"error\": \"The AI detection service is not configured.\"}");
        }

        List<MistralMessage> messages = List.of(
            new MistralMessage("system", SYSTEM_PROMPT),
            new MistralMessage("user", textToAnalyze)
        );
        MistralRequest payload = new MistralRequest(mistralModel, messages, false);

        return webClient.post()
                .uri(mistralApiUrl)
                .header("Authorization", "Bearer " + mistralApiKey)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(payload)
                .retrieve()
                .bodyToMono(MistralResponse.class)
                .timeout(Duration.ofSeconds(15))
                .retryWhen(Retry.backoff(2, Duration.ofSeconds(2))
                        .jitter(0.5)
                        .filter(throwable -> throwable instanceof WebClientResponseException || throwable instanceof TimeoutException)
                        .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -> retrySignal.failure()))
                .map(this::processMistralResponse)
                .onErrorResume(e -> {
                    System.err.println("Error calling Mistral API: " + e.getMessage());
                    if (e instanceof WebClientResponseException wcre && wcre.getStatusCode() == HttpStatus.UNAUTHORIZED) {
                        return Mono.just("{\"error\": \"The Mistral API key is invalid. Please check your configuration.\"}");
                    }
                    return Mono.just("{\"error\": \"The AI service is currently unavailable. Please try again later.\"}");
                });
    }

    private String processMistralResponse(MistralResponse apiResponse) {
        if (apiResponse == null || apiResponse.choices() == null || apiResponse.choices().isEmpty()) {
            return "{\"error\": \"The AI model returned an empty response.\"}";
        }
        Choice firstChoice = apiResponse.choices().get(0);
        if (firstChoice.message() == null || firstChoice.message().content() == null || firstChoice.message().content().isBlank()) {
            return "{\"error\": \"The AI model returned a message with no content.\"}";
        }
        String content = firstChoice.message().content().trim();
        int jsonStart = content.indexOf('{');
        int jsonEnd = content.lastIndexOf('}');
        if (jsonStart != -1 && jsonEnd != -1 && jsonEnd > jsonStart) {
            String extractedJson = content.substring(jsonStart, jsonEnd + 1);
            String sanitizedJson = sanitizeJsonString(extractedJson);
            try {
                objectMapper.readTree(sanitizedJson);
                return sanitizedJson;
            } catch (JsonProcessingException e) {
                System.err.println("Failed to parse JSON even after robust sanitizing. Raw content: " + content);
                return "{\"error\": \"The AI model returned a malformed JSON response.\"}";
            }
        }
        
        System.err.println("Failed to find any JSON in raw content: " + content);
        return "{\"error\": \"Could not find a valid JSON object in the AI's response.\"}";
    }

    private String sanitizeJsonString(String json) {
        StringBuilder sanitized = new StringBuilder();
        boolean inString = false;
        boolean isEscaped = false;

        for (char c : json.toCharArray()) {
            if (c == '\"') {
                if (!isEscaped) {
                    inString = !inString;
                }
                isEscaped = false;
            } else if (c == '\\') {
                isEscaped = !isEscaped;
            } else {
                isEscaped = false;
            }
            if (inString && (c == '\n' || c == '\r')) {
                sanitized.append("\\n");
            } else {
                sanitized.append(c);
            }
        }
        return sanitized.toString();
    }
}
