package com.springboot.ai_verify.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import java.time.Duration;
import java.util.List;
import java.util.concurrent.TimeoutException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
public class AiDetectionService {

    private final WebClient webClient;
    private final ObjectMapper objectMapper;

    @Value("${mistralmodel.api.url}")
    private String mistralApiUrl;

    @Value("${mistralmodel.api.key}")
    private String mistralApiKey;

    @Value("${mistralmodel.model}")
    private String mistralModel;

    private static final String SYSTEM_PROMPT = """
        Analyze the given text and assess the likelihood that it was generated by an AI versus a human. 
        Provide ONLY a JSON response in this exact format. All newlines inside JSON string values (e.g., in the 'analysis' field) MUST be escaped as \\n. All double quotes inside any JSON string value MUST be escaped as \\\".
        {
          "probability": 0-100,
          "metrics": {
            "perplexity": 0-100,
            "burstiness": 0-100,
            "consistency": 0-100
          },
          "patterns": ["pattern1", "pattern2", ...],
          "analysis": "Detailed explanation of the findings, summarizing why the text is likely AI or human-written based on the metrics."
        }
        """;

    public AiDetectionService(WebClient.Builder webClientBuilder, ObjectMapper objectMapper) {
        this.webClient = webClientBuilder.build();
        this.objectMapper = objectMapper;
    }

    public record MistralMessage(String role, String content) {}
    public record MistralRequest(String model, List<MistralMessage> messages, boolean stream) {}
    public record MistralResponse(List<Choice> choices) {}
    public record Choice(MistralMessage message) {}

    public Mono<String> detectAiContent(String textToAnalyze) {
        if (mistralApiKey == null || mistralApiKey.isBlank()) {
            return Mono.just("{\"error\": \"The AI detection service is not configured.\"}");
        }

        List<MistralMessage> messages = List.of(
                new MistralMessage("system", SYSTEM_PROMPT),
                new MistralMessage("user", textToAnalyze)
        );
        MistralRequest payload = new MistralRequest(mistralModel, messages, false);

        return webClient.post()
                .uri(mistralApiUrl)
                .header("Authorization", "Bearer " + mistralApiKey)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(payload)
                .retrieve()
                .bodyToMono(MistralResponse.class)
                .timeout(Duration.ofSeconds(12))
                .retryWhen(Retry.backoff(2, Duration.ofSeconds(2))
                        .jitter(0.5)
                        .filter(throwable -> throwable instanceof WebClientResponseException || throwable instanceof TimeoutException)
                        .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -> retrySignal.failure()))
                .map(this::processMistralResponse)
                .onErrorResume(e -> {
                    System.err.println("Error calling Mistral API: " + e.getMessage());
                    if (e instanceof WebClientResponseException wcre && wcre.getStatusCode() == HttpStatus.UNAUTHORIZED) {
                        return Mono.just("{\"error\": \"The Mistral API key is invalid. Please check your configuration.\"}");
                    }
                    return Mono.just("{\"error\": \"The AI service is currently unavailable. Please try again later.\"}");
                });
    }

    private String processMistralResponse(MistralResponse apiResponse) {
        if (apiResponse == null || apiResponse.choices() == null || apiResponse.choices().isEmpty()) {
            return "{\"error\": \"The AI model returned an empty response.\"}";
        }

        Choice firstChoice = apiResponse.choices().get(0);
        if (firstChoice.message() == null || firstChoice.message().content() == null || firstChoice.message().content().isBlank()) {
            return "{\"error\": \"The AI model returned a message with no content.\"}";
        }

        String content = firstChoice.message().content().trim();

        int jsonStart = content.indexOf('{');
        int jsonEnd = content.lastIndexOf('}');

        if (jsonStart != -1 && jsonEnd != -1 && jsonEnd > jsonStart) {
            String extractedJson = content.substring(jsonStart, jsonEnd + 1);

            // Try to parse the extracted JSON as-is first
            try {
                objectMapper.readTree(extractedJson);
                return extractedJson;
            } catch (JsonProcessingException e) {
                System.err.println("Initial JSON parse failed. Attempting basic repair...");

                // Repair: escape newlines and double quotes inside string values
                Pattern pattern = Pattern.compile("(:\\s?\")([^\"]*?)(\")");
                Matcher matcher = pattern.matcher(extractedJson);
                StringBuffer sb = new StringBuffer();

                while (matcher.find()) {
                    String prefix = matcher.group(1);
                    String inner = matcher.group(2);
                    String suffix = matcher.group(3);
                    inner = inner.replace("\n", "\\n").replace("\"", "\\\"");
                    matcher.appendReplacement(sb, prefix + inner + suffix);
                }
                matcher.appendTail(sb);
                String sanitizedJson = sb.toString();

                try {
                    objectMapper.readTree(sanitizedJson);
                    return sanitizedJson;
                } catch (JsonProcessingException ex) {
                    System.err.println("Still failed JSON parse. Raw: " + extractedJson);
                    return "{\"error\": \"The AI model returned malformed JSON that could not be fixed.\"}";
                }
            }
        }

        System.err.println("Failed to find any JSON in raw content: " + content);
        return "{\"error\": \"Could not find a valid JSON object in the AI's response.\"}";
    }
}
