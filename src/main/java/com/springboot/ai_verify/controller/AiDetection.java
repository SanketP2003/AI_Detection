package com.springboot.ai_verify.controller;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.List;
import java.util.Map;

@RestController
@CrossOrigin(origins = "*")
@RequestMapping("/api/detect")
public class AiDetection {

    private final WebClient webClient;
    private final ObjectMapper objectMapper;

    private static final String SYSTEM_PROMPT = """
        Analyze the given text and assess the likelihood that it was generated by an AI versus a human. 
        Use a multifaceted evaluation strategy based on natural language features, writing dynamics, and 
        the matic coherence. The assessment must be grounded in the following metrics and considerations:
        Evaluation Metrics:
        Perplexity (0–100):
        Measures how predictable the text is. AI-generated content typically uses highly probable next-word predictions,
        leading to lower perplexity scores (e.g., 0–40). Human writing often introduces less predictable language, creative phrasings, 
        idioms, and interruptions that result in higher perplexity (e.g., 40–70). Very high perplexity (>70) may indicate incoherence 
        or randomness, suggesting either low-quality AI output or disorganized human writing.
        Burstiness (0–100):
        Evaluates variance in sentence structure, length, punctuation, and rhythm. Human writers tend to have irregular patterns, 
        mixing short and long sentences and switching between formal and informal tones. This results in high burstiness (60–100). 
        AI-generated content often exhibits low burstiness (20–50), maintaining consistent sentence length and syntactic simplicity.
        Consistency (0–100):
        Reflects the thematic and stylistic steadiness of the text. AI text is often overly consistent, staying narrowly on topic, 
        rarely diverging in tone or context (scoring 70–100). Human writing often shifts tone, introduces side thoughts, and shows 
        personal bias or emotion, which lowers consistency (30–60). Extremely low consistency (<30) may indicate lack of focus or clarity.
        Provide a JSON response in this format:
        {
          "probability": 0-100,
          "metrics": {
            "perplexity": 0-100,
            "burstiness": 0-100,
            "consistency": 0-100
          },
          "patterns": ["pattern1", "pattern2", ...],
          "analysis": "Detailed explanation of the findings"
        }
        """;

    @Value("${gemini.api.url}")
    private String geminiApiUrl;

    @Value("${gemini.api.key}")
    private String geminiApiKey;

    public AiDetection(WebClient.Builder webClientBuilder, ObjectMapper objectMapper) {
        this.webClient = webClientBuilder.build();
        this.objectMapper = objectMapper;
    }

    @PostMapping("/bulk-ai")
    public Mono<ResponseEntity<? extends Map<String,? extends Object>>> detectContent(@RequestBody Map<String, String> request) {
        String textToAnalyze = request.get("text");

        if (textToAnalyze == null || textToAnalyze.trim().isEmpty()) {
            return Mono.just(ResponseEntity.badRequest().body(Map.of("error", "Text content is required")));
        }

        Map<String, Object> payload = Map.of(
                "contents", List.of(
                        Map.of("role", "user", "parts", List.of(
                                Map.of("text", SYSTEM_PROMPT + "\n\nText:\n" + textToAnalyze)
                        ))
                )
        );

        return webClient.post()
                .uri(geminiApiUrl + "?key=" + geminiApiKey)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(payload)
                .retrieve()
                .bodyToMono(String.class)
                .timeout(Duration.ofSeconds(30))
                .flatMap(responseBody -> {
                    try {
                        Map<String, Object> map = objectMapper.readValue(responseBody, new TypeReference<>() {});
                        List<?> candidates = (List<?>) map.get("candidates");
                        Map<?, ?> candidate = (Map<?, ?>) candidates.get(0);
                        Map<?, ?> content = (Map<?, ?>) candidate.get("content");
                        List<?> parts = (List<?>) content.get("parts");
                        Map<?, ?> part = (Map<?, ?>) parts.get(0);
                        String rawText = part.get("text").toString();

                        // Clean up markdown block (if present)
                        String jsonText = rawText.trim();
                        if (jsonText.startsWith("```")) {
                            int firstNewline = jsonText.indexOf('\n');
                            int lastBacktick = jsonText.lastIndexOf("```");
                            if (firstNewline != -1 && lastBacktick != -1) {
                                jsonText = jsonText.substring(firstNewline + 1, lastBacktick).trim();
                            }
                        }

                        Map<String, Object> parsed = objectMapper.readValue(jsonText, new TypeReference<>() {});
                        return Mono.just(ResponseEntity.ok(parsed));

                    } catch (Exception e) {
                        return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(Map.of("error", "Failed to parse Gemini response", "details", e.getMessage())));
                    }
                })
                .onErrorResume(err ->
                        Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(Map.of("error", "Gemini request failed", "details", err.getMessage())))
                );
    }
}
